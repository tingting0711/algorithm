# 排序
## 冒泡排序  - O(N<sup>2</sup>)

- 可以实现稳定排序



## 选择排序  - O(N<sup>2</sup>)

- 无法实现稳定排序



## 插入排序  - O(N~N<sup>2</sup>)

- 可以实现稳定排序

- 与数据状况有关，若原数组有序，则时间复杂度为O(N)

  

## 归并排序  - O(N*logN)

- 可以实现稳定排序





## 快速排序  - O(N*logN)

- 无法实现稳定排序

  

## 堆  排  序  - O(N*logN)

- 无法实现稳定排序





## 桶排序  - O(N)
1. 计数排序  - O(N)
2. 基数排序  - O(N)



## 小和问题 - 归并排序

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组
的小和。

例子:
[1,3,4,2,5]
1左边比1小的数，没有;
3左边比3小的数，1;
4左边比4小的数，1、3;
2左边比2小的数，1;
5左边比5小的数，1、3、4、2;
所以小和为1+1+3+1+1+3+4+2=16



## 逆序对问题 - 归并排序

在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序
对。



## 荷兰国旗 - 

给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放在数组的中间，大于num的数放在数组的 右边。 

要求额外空间复杂度O(1)，时间复杂度O(N) 


# 二分

# 高精度

#前缀和与差分



#双指针算法



#位运算

- n的二进制表示中第k位是几
  - 将第k位移到个位， 右移
  - 查看个位数
  - (n >> k )&& 1
- lowbit : 返回x的最后一位1
  - x & -x  ==  x &(~x + 1)



#离散化

- 整数离散化
- 值域较大，个数较少 
- 去重
- 二分求出x对应的离散化值

```
#去重
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end())

#二分离散
int find(int x) //找到第一个大于等于x的位置
{
	int l = 0, r = alls.size() - 1;
	while(l < r)
	{
		int mid = l + r >> 1;
		if(alls[mid] >= x)r = mid;
		else l = mid + 1;
	}
	return r + 1; //映射到1，2，3， ...n;

}
```

> 802区间和

```

```



#区间合并